<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Converge MVP Test - V13 Fix & Cyclus Teller</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #version-info { 
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.0em;
            color: #555;
        }
        #mode-toggle { 
            position: absolute;
            top: 40px;
            left: 20px;
            font-size: 0.9em;
        }
        #status-area {
            margin-bottom: 20px;
            font-size: 1.2em;
            height: 25px;
            color: #00ff88;
        }
        #cycle-counter { /* NIEUW: Cyclus Teller (boven het midden) */
            position: absolute;
            top: 60px;
            font-size: 2.5em;
            font-weight: bold;
            color: #fff;
            opacity: 0.8;
            pointer-events: none; /* Zorgt ervoor dat de muis erdoorheen kan klikken */
        }
        #score-area {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
        }
        #game-container {
            position: relative;
            width: 500px;
            height: 500px;
            border: 1px solid #333;
            background-color: #111;
        }
        .dot {
            position: absolute;
            width: 40px; 
            height: 40px; 
            cursor: pointer; 
            transition: background-color 0.1s, transform 0.1s;
            z-index: 100;
            display: none; 
        }
        #dot1 { background-color: #00ff88; } /* Groen */
        #dot2 { background-color: #ffaa00; } /* Oranje */
        #dot3 { background-color: #ffff00; } /* Geel */

        .footprint { display: none; } 
        
        #try-again-btn {
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #f00;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }
    </style>
</head>
<body>

<div id="version-info">V13</div>
<div id="mode-toggle">
    <input type="checkbox" id="einstein-mode">
    <label for="einstein-mode">Einstein Mode</label>
</div>
<div id="cycle-counter"></div> <div id="score-area">Cyclus Voltooid: <span id="score-value">0</span></div>
<div id="status-area">Wacht op beweging...</div>
<div id="game-container">
    <div id="dot1" class="dot"></div>
    <div id="dot2" class="dot"></div>
    <div id="dot3" class="dot"></div> 
</div>
<button id="try-again-btn">Try Again</button>

<script>
    const container = document.getElementById('game-container');
    const dot1 = document.getElementById('dot1');
    const dot2 = document.getElementById('dot2');
    const dot3 = document.getElementById('dot3'); 
    const scoreValue = document.getElementById('score-value');
    const statusArea = document.getElementById('status-area');
    const tryAgainBtn = document.getElementById('try-again-btn');
    const einsteinMode = document.getElementById('einstein-mode');
    const cycleCounter = document.getElementById('cycle-counter'); // NIEUW
    
    const gridSize = 10; 
    const unitSize = container.offsetWidth / gridSize;
    const movementSpeed = 750;
    const CLICKS_PER_CYCLE = 3; // 3 klikken per kleur voordat het volgende blok komt
    
    // --- PATRONEN EN STARTPOSITIES ---
    const PATTERNS = [
        [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }], // Pendelaar
        [{ dx: 2, dy: 0 }, { dx: 0, dy: -2 }, { dx: -2, dy: 0 }, { dx: 0, dy: -2 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 0 }], // Spiraal
        [{ dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }, { dx: 0, dy: 0 }], // Diagonaal
        [{ dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 0 }, { dx: 0, dy: 0 }, { dx: 0, dy: 0 }, { dx: 0, dy: 0 }] // Kleine Cirkel
    ];
    const START_POSITIONS = [{ x: 5, y: 5 }, { x: 2, y: 9 }, { x: 8, y: 3 }, { x: 1, y: 1 }, { x: 10, y: 10 }];

    // --- OPGESLAGEN (BEWAARDE) PATRONEN en Posities ---
    let savedPattern = { 1: [], 2: [], 3: [] }; // Key: dotIndex
    let savedStartPos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 }, 3: { x: 0, y: 0 } };

    // --- STATE BEHEER ---
    let currentPos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 }, 3: { x: 0, y: 0 } }; // ACTUELE positie
    let stepCount = { 1: 0, 2: 0, 3: 0 };
    let cycleCount = { 1: 0, 2: 0, 3: 0 }; // NIEUW: Houdt bij hoe vaak er geklikt is in de cyclus
    let activeDot = 1;
    let isMoving = { 1: false, 2: false, 3: false }; 
    let intervalId = { 1: null, 2: null, 3: null }; 
    let score = 0;

    // --- INITIALISATIE & RESET LOGICA ---

    function initializeGame() {
        // Stop alle timers
        Object.values(intervalId).forEach(clearInterval);
        
        // 1. Willekeurige patronen en posities selecteren en opslaan
        for (let i = 1; i <= 3; i++) {
            const randPatternIndex = Math.floor(Math.random() * PATTERNS.length);
            const randPosIndex = Math.floor(Math.random() * START_POSITIONS.length);
            savedPattern[i] = PATTERNS[randPatternIndex];
            savedStartPos[i] = { ...START_POSITIONS[randPosIndex] };
        }

        // Reset state
        score = 0;
        scoreValue.textContent = score;
        activeDot = 1; // Start altijd met Groen
        cycleCount = { 1: 0, 2: 0, 3: 0 };
        
        // Start de eerste cyclus
        startDotMovement(1);
    }

    // --- HELPER FUNCTIES ---

    function updateStatus(message, color = '#00ff88') {
        statusArea.innerHTML = message;
        statusArea.style.color = color;
    }
    
    // NIEUW: Update de cyclus teller
    function updateCycleCounter(dotIndex) {
        const remaining = CLICKS_PER_CYCLE - cycleCount[dotIndex];
        if (remaining > 0 && cycleCount[dotIndex] > 0) {
            cycleCounter.textContent = remaining;
        } else {
            cycleCounter.textContent = '';
        }
    }

    function updateDotPosition(dotElement, gridX, gridY) {
        const left = (gridX * unitSize) - (dotElement.offsetWidth / 2);
        const top = (gridY * unitSize) - (dotElement.offsetHeight / 2);
        dotElement.style.left = `${left}px`;
        dotElement.style.top = `${top}px`;
    }

    function checkBoundaries(x, y) {
        x = Math.max(1, Math.min(gridSize, x));
        y = Math.max(1, Math.min(gridSize, y));
        return { x: x, y: y };
    }

    function clickFeedback(dotElement, originalColor) {
        dotElement.style.backgroundColor = '#fff';
        setTimeout(() => {
            dotElement.style.backgroundColor = originalColor;
        }, 250); 
    }

    // --- START FUNCTIES VOOR ELK BLOK ---

    function startDotMovement(dotIndex) {
        // Stop alle bewegingen en verberg blokken
        Object.values(intervalId).forEach(clearInterval);
        isMoving = { 1: false, 2: false, 3: false };
        [dot1, dot2, dot3].forEach(d => d.style.display = 'none');
        cycleCounter.textContent = '';

        activeDot = dotIndex;
        
        // Reset/Initialiseer de positie en stapcount met de BEWAARDE startpositie
        currentPos[dotIndex] = { ...savedStartPos[dotIndex] };
        stepCount[dotIndex] = 0;
        isMoving[dotIndex] = true;
        
        const dot = (dotIndex === 1) ? dot1 : (dotIndex === 2) ? dot2 : dot3;
        const color = (dotIndex === 1) ? '#00ff88' : (dotIndex === 2) ? '#ffaa00' : '#ffff00';
        const name = (dotIndex === 1) ? 'Groen' : (dotIndex === 2) ? 'Oranje' : 'Geel';
        
        dot.style.backgroundColor = color;
        dot.style.display = 'block';

        updateDotPosition(dot, currentPos[dotIndex].x, currentPos[dotIndex].y);
        
        const moveFunction = (dotIndex === 1) ? moveDot1 : (dotIndex === 2) ? moveDot2 : moveDot3;
        intervalId[dotIndex] = setInterval(moveFunction, movementSpeed);
        
        updateCycleCounter(dotIndex);
        updateStatus(`Aan de beurt: Blok ${dotIndex} (${name}). Onthoud het patroon!`, color);
    }
    
    function failGame() {
        Object.values(intervalId).forEach(clearInterval);
        isMoving = { 1: false, 2: false, 3: false };
        dot1.style.backgroundColor = dot2.style.backgroundColor = dot3.style.backgroundColor = '#ff0000'; 
        updateStatus("MISLUKT: Tijd is om! Druk op 'Try Again'.", '#ff0000');
        tryAgainBtn.style.display = 'block';
    }


    // --- BEWEGINGSLUSSEN (Gebruiken nu de bewaarde patronen) ---
    
    // Functie om de bewegingslogica voor elk blok te genereren
    function createMoveDotFunction(dotIndex) {
        return function() {
            if (!isMoving[dotIndex]) return;

            const pattern = savedPattern[dotIndex];
            const currentStep = stepCount[dotIndex];
            
            if (currentStep >= pattern.length) {
                failGame();
                return;
            }

            const step = pattern[currentStep];
            
            let newPos = checkBoundaries(currentPos[dotIndex].x + step.dx, currentPos[dotinndex].y + step.dy);
            currentPos[dotIndex] = newPos;
            
            const dot = (dotIndex === 1) ? dot1 : (dotIndex === 2) ? dot2 : dot3;
            updateDotPosition(dot, currentPos[dotIndex].x, currentPos[dotIndex].y);

            stepCount[dotIndex]++;
        };
    }

    const moveDot1 = createMoveDotFunction(1);
    const moveDot2 = createMoveDotFunction(2);
    const moveDot3 = createMoveDotFunction(3);


    // --- KLIK HANDLERS & SEQUENTIELE FLOW ---

    function handleSuccessfulClick(dotIndex, dotElement, originalColor, nextDotIndex) {
        if (!isMoving[dotIndex] || stepCount[dotIndex] === 0 || stepCount[dotIndex] >= savedPattern[dotIndex].length) return;

        clickFeedback(dotElement, originalColor);
        score++;
        scoreValue.textContent = score;
        cycleCount[dotIndex]++;

        const name = (dotIndex === 1) ? 'Groen' : (dotIndex === 2) ? 'Oranje' : 'Geel';
        updateStatus(`SUCCES! Blok ${dotIndex} cyclus voltooid! (${score}x)`, originalColor);
        
        if (cycleCount[dotIndex] >= CLICKS_PER_CYCLE) {
            // Cyclus voltooid, ga naar volgend blok
            cycleCount[dotIndex] = 0; // Reset de teller voor dit blok
            startDotMovement(nextDotIndex);
        } else {
            // Start de cyclus van dit blok opnieuw (nieuwe beweging, zelfde patroon)
            startDotMovement(dotIndex);
        }
    }


    dot1.onclick = function() {
        // Groen (1) gaat naar Oranje (2)
        handleSuccessfulClick(1, dot1, '#00ff88', 2);
    };
    
    dot2.onclick = function() { 
        // Oranje (2) gaat naar Geel (3)
        handleSuccessfulClick(2, dot2, '#ffaa00', 3);
    };
    
    dot3.onclick = function() { 
        // Geel (3) gaat naar Groen (1)
        handleSuccessfulClick(3, dot3, '#ffff00', 1);
    };

    // --- RESET LOGICA (Einstein Mode) ---

    tryAgainBtn.onclick = function() {
        tryAgainBtn.style.display = 'none';

        if (einsteinMode.checked) {
            // Einstein Mode: Begin totaal opnieuw met nieuwe willekeurige patronen
            updateStatus("Einstein Mode: Nieuwe patronen geladen!", '#ff00ff');
            initializeGame(); 
        } else {
            // Normale Mode: Herstart de actieve cyclus met de OPGESLAGEN patronen
            score = 0;
            scoreValue.textContent = score;
            
            // Reset cyclus counts
            cycleCount = { 1: 0, 2: 0, 3: 0 };

            // Start het blok dat aan de beurt was
            startDotMovement(activeDot);
        }
    };

    // Initialisatie van het spel
    initializeGame();
</script>

</body>
</html>
