<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>Converge MVP Test - V15 Willekeurige Timing</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #version-info { 
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.0em;
            color: #555;
        }
        #mode-toggle { 
            position: absolute;
            top: 40px;
            left: 20px;
            font-size: 0.9em;
        }
        #status-area {
            margin-bottom: 20px;
            font-size: 1.2em;
            height: 25px;
            color: #00ff88;
        }
        #cycle-counter { 
            position: absolute;
            top: 60px;
            font-size: 2.5em;
            font-weight: bold;
            color: #fff;
            opacity: 0.8;
            pointer-events: none; 
        }
        #timing-cue { /* NIEUW: Voor de willekeurige klikstap */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 5em;
            color: #fff;
            z-index: 200;
            display: none;
        }
        #score-area {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5em;
        }
        #game-container {
            position: relative;
            width: 500px;
            height: 500px;
            border: 1px solid #333;
            background-color: #111;
        }
        .dot {
            position: absolute;
            width: 40px; 
            height: 40px; 
            cursor: pointer; 
            transition: background-color 0.1s, transform 0.1s;
            z-index: 100;
            display: none; 
        }
        #dot1 { background-color: #00ff88; } /* Groen */
        #dot2 { background-color: #ffaa00; } /* Oranje */
        #dot3 { background-color: #ffff00; } /* Geel */

        .footprint { display: none; } 
        
        #try-again-btn {
            padding: 10px 20px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #f00;
            color: white;
            border: none;
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }
    </style>
</head>
<body>

<div id="version-info">V15</div>
<div id="mode-toggle">
    <input type="checkbox" id="einstein-mode">
    <label for="einstein-mode">Einstein Mode</label>
</div>
<div id="timing-cue"></div> <div id="cycle-counter"></div>
<div id="score-area">Cyclus Voltooid: <span id="score-value">0</span></div>
<div id="status-area">Wacht op beweging...</div>
<div id="game-container">
    <div id="dot1" class="dot"></div>
    <div id="dot2" class="dot"></div>
    <div id="dot3" class="dot"></div> 
</div>
<button id="try-again-btn">Try Again</button>

<script>
    const container = document.getElementById('game-container');
    const dot1 = document.getElementById('dot1');
    const dot2 = document.getElementById('dot2');
    const dot3 = document.getElementById('dot3'); 
    const scoreValue = document.getElementById('score-value');
    const statusArea = document.getElementById('status-area');
    const tryAgainBtn = document.getElementById('try-again-btn');
    const einsteinMode = document.getElementById('einstein-mode');
    const cycleCounter = document.getElementById('cycle-counter');
    const timingCue = document.getElementById('timing-cue'); // NIEUW
    
    const gridSize = 10; 
    const unitSize = container.offsetWidth / gridSize;
    const movementSpeed = 750;
    const CLICKS_PER_CYCLE = 3; 
    const MAX_STEPS = 10; // Maximale lengte van elk patroon
    
    // --- PATRONEN EN STARTPOSITIES ---
    // Alle patronen zijn nu 10 stappen lang.
    const PATTERNS = [
        [{ dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 0 }], 
        [{ dx: 2, dy: 0 }, { dx: 0, dy: -2 }, { dx: -2, dy: 0 }, { dx: 0, dy: -2 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: 0 }],
        [{ dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }, { dx: 1, dy: -1 }, { dx: -1, dy: -1 }, { dx: -1, dy: 1 }, { dx: 1, dy: 1 }, { dx: 0, dy: 0 }],
        [{ dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 1, dy: 0 }, { dx: 0, dy: -1 }, { dx: -1, dy: 0 }, { dx: 0, dy: 0 }, { dx: 0, dy: 0 }]
    ];
    const START_POSITIONS = [{ x: 5, y: 5 }, { x: 2, y: 9 }, { x: 8, y: 3 }, { x: 1, y: 1 }, { x: 10, y: 10 }];

    // --- OPGESLAGEN STATE (Patronen en Start/Klik stappen) ---
    let savedPattern = { 1: [], 2: [], 3: [] }; 
    let savedStartPos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 }, 3: { x: 0, y: 0 } };
    let savedClickStep = { 1: 0, 2: 0, 3: 0 }; // NIEUW: De willekeurige stap waarop geklikt moet worden

    // --- ACTUELE STATE ---
    let currentPos = { 1: { x: 0, y: 0 }, 2: { x: 0, y: 0 }, 3: { x: 0, y: 0 } }; 
    let stepCount = { 1: 0, 2: 0, 3: 0 };
    let cycleCount = { 1: 0, 2: 0, 3: 0 }; 
    let activeDot = 1;
    let isMoving = { 1: false, 2: false, 3: false }; 
    let intervalId = { 1: null, 2: null, 3: null }; 
    let score = 0;

    // --- INITIALISATIE & RESET LOGICA ---

    function initializeGame() {
        Object.values(intervalId).forEach(clearInterval);
        
        // 1. Willekeurige patronen, posities en KLIK-STAPPEN selecteren en opslaan
        for (let i = 1; i <= 3; i++) {
            const randPatternIndex = Math.floor(Math.random() * PATTERNS.length);
            const randPosIndex = Math.floor(Math.random() * START_POSITIONS.length);
            
            savedPattern[i] = PATTERNS[randPatternIndex];
            savedStartPos[i] = { ...START_POSITIONS[randPosIndex] };
            
            // Willekeurige klikstap tussen 2 en 9 (stap 1 is na de eerste beweging)
            savedClickStep[i] = Math.floor(Math.random() * 8) + 2; 
        }

        score = 0;
        scoreValue.textContent = score;
        activeDot = 1;
        cycleCount = { 1: 0, 2: 0, 3: 0 };
        
        // Eerst de cue laten zien, daarna pas de beweging starten
        showTimingCue(1);
    }
    
    // --- HELPER FUNCTIES ---

    function updateStatus(message, color = '#00ff88') {
        statusArea.innerHTML = message;
        statusArea.style.color = color;
    }
    
    function updateCycleCounter(dotIndex) {
        const remaining = CLICKS_PER_CYCLE - cycleCount[dotIndex];
        if (remaining > 0) {
            cycleCounter.textContent = remaining;
        } else {
            cycleCounter.textContent = '';
        }
    }

    function updateDotPosition(dotElement, gridX, gridY) {
        const left = (gridX * unitSize) - (dotElement.offsetWidth / 2);
        const top = (gridY * unitSize) - (dotElement.offsetHeight / 2);
        dotElement.style.left = `${left}px`;
        dotElement.style.top = `${top}px`;
    }

    function checkBoundaries(x, y) {
        x = Math.max(1, Math.min(gridSize, x));
        y = Math.max(1, Math.min(gridSize, y));
        return { x: x, y: y };
    }

    function clickFeedback(dotElement, originalColor) {
        dotElement.style.backgroundColor = '#fff';
        setTimeout(() => {
            dotElement.style.backgroundColor = originalColor;
        }, 250); 
    }
    
    // NIEUW: Toon de willekeurige klikstap
    function showTimingCue(dotIndex) {
        Object.values(intervalId).forEach(clearInterval);
        isMoving = { 1: false, 2: false, 3: false };
        [dot1, dot2, dot3].forEach(d => d.style.display = 'none');
        cycleCounter.textContent = '';
        tryAgainBtn.style.display = 'none';

        const step = savedClickStep[dotIndex];
        timingCue.textContent = step;
        timingCue.style.display = 'block';
        
        // Wacht 1.5 seconde, dan start de beweging
        setTimeout(() => {
            timingCue.style.display = 'none';
            startDotMovement(dotIndex);
        }, 1500); 
    }

    // --- START FUNCTIES VOOR ELK BLOK ---

    function startDotMovement(dotIndex) {
        // Alleen de actieve blok moet opnieuw gestart worden, de rest is al gestopt
        clearInterval(intervalId[dotIndex]);
        
        activeDot = dotIndex;
        currentPos[dotIndex] = { ...savedStartPos[dotIndex] }; // Reset naar STARTPOS
        stepCount[dotIndex] = 0;
        isMoving[dotIndex] = true;
        
        const dot = (dotIndex === 1) ? dot1 : (dotIndex === 2) ? dot2 : dot3;
        const color = (dotIndex === 1) ? '#00ff88' : (dotIndex === 2) ? '#ffaa00' : '#ffff00';
        const name = (dotIndex === 1) ? 'Groen' : (dotIndex === 2) ? 'Oranje' : 'Geel';
        
        dot.style.backgroundColor = color;
        dot.style.display = 'block';
        updateDotPosition(dot, currentPos[dotIndex].x, currentPos[dotIndex].y);
        
        intervalId[dotIndex] = setInterval(createMoveDotFunction(dotIndex), movementSpeed);
        
        const requiredStep = savedClickStep[dotIndex];
        updateCycleCounter(dotIndex);
        updateStatus(`Aan de beurt: Blok ${dotIndex} (${name}). KLIK op stap ${requiredStep}.`, color);
    }
    
    function failGame(reason) {
        Object.values(intervalId).forEach(clearInterval);
        isMoving = { 1: false, 2: false, 3: false };
        dot1.style.backgroundColor = dot2.style.backgroundColor = dot3.style.backgroundColor = '#ff0000'; 
        cycleCounter.textContent = '';
        tryAgainBtn.style.display = 'block';
        updateStatus(`MISLUKT (${reason})! Druk op 'Try Again'.`, '#ff0000');
    }


    // --- BEWEGINGSLUSSEN ---
    
    function createMoveDotFunction(dotIndex) {
        return function() {
            if (!isMoving[dotIndex]) return;

            const pattern = savedPattern[dotIndex];
            const requiredStep = savedClickStep[dotIndex];

            // 1. CHECK OP TE LAAT: Als de stap het vereiste moment bereikt
            if (stepCount[dotIndex] === requiredStep) {
                failGame("Te laat geklikt");
                return;
            }
            
            // 2. CHECK OP PATROONEINDE (Veiligheid): Als het patroon is afgelopen
            if (stepCount[dotIndex] >= MAX_STEPS) {
                failGame("Patroon voltooid zonder actie");
                return;
            }

            const step = pattern[stepCount[dotIndex]];
            
            let newPos = checkBoundaries(currentPos[dotIndex].x + step.dx, currentPos[dotIndex].y + step.dy);
            currentPos[dotIndex] = newPos;
            
            const dot = (dotIndex === 1) ? dot1 : (dotIndex === 2) ? dot2 : dot3;
            updateDotPosition(dot, currentPos[dotIndex].x, currentPos[dotIndex].y);

            stepCount[dotIndex]++;
        };
    }

    // --- KLIK HANDLERS & SEQUENTIELE FLOW ---

    function handleSuccessfulClick(dotIndex, dotElement, originalColor, nextDotIndex) {
        // 1. Controleer of de juiste dot beweegt
        if (!isMoving[dotIndex]) return;

        const currentStep = stepCount[dotIndex];
        const requiredStep = savedClickStep[dotIndex];

        // 2. FALEN: Te vroeg of te laat geklikt
        if (currentStep !== requiredStep) {
            failGame(`Geklikt op stap ${currentStep}, vereist was ${requiredStep}`);
            return;
        }
        
        // 3. SUCCES
        clickFeedback(dotElement, originalColor);
        score++;
        scoreValue.textContent = score;
        cycleCount[dotIndex]++;

        const name = (dotIndex === 1) ? 'Groen' : (dotIndex === 2) ? 'Oranje' : 'Geel';
        updateStatus(`GOED! Klik op stap ${requiredStep} gelukt. Clicks over: ${CLICKS_PER_CYCLE - cycleCount[dotIndex]}`, originalColor);
        
        if (cycleCount[dotIndex] >= CLICKS_PER_CYCLE) {
            // Cyclus voltooid (3 clicks), ga naar volgend blok
            cycleCount[dotIndex] = 0; 
            showTimingCue(nextDotIndex);
        } else {
            // Start de cyclus van dit blok opnieuw (zelfde patroon, maar nieuwe beweging)
            showTimingCue(dotIndex);
        }
    }


    dot1.onclick = function() {
        handleSuccessfulClick(1, dot1, '#00ff88', 2);
    };
    
    dot2.onclick = function() { 
        handleSuccessfulClick(2, dot2, '#ffaa00', 3);
    };
    
    dot3.onclick = function() { 
        handleSuccessfulClick(3, dot3, '#ffff00', 1);
    };

    // --- RESET LOGICA ---

    tryAgainBtn.onclick = function() {
        if (einsteinMode.checked) {
            // Einstein Mode: Nieuwe patronen en volledig gereset
            updateStatus("Einstein Mode: Nieuwe patronen geladen!", '#ff00ff');
            initializeGame(); 
        } else {
            // Normale Mode: Herstart de actieve cyclus met de OPGESLAGEN patronen
            score = 0;
            scoreValue.textContent = score;
            cycleCount = { 1: 0, 2: 0, 3: 0 }; 
            
            // Start met het tonen van de timing cue van de laatst actieve dot
            showTimingCue(activeDot);
        }
    };

    // Initialisatie van het spel
    initializeGame();
</script>

</body>
</html>
